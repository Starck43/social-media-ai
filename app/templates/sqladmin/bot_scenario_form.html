{% extends "sqladmin/base_form.html" %}

{% block extra_css %}
    {{ super() }}
    <style>
		/* Секции формы */
		.form-section {
			padding: 24px;
			margin-bottom: 24px;
		}

		.form-section-title {
			font-size: 1.1rem;
			font-weight: bold;
			margin-bottom: 16px;
			color: var(--tblr-body-color);
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.form-section-title i {
			color: var(--tblr-primary);
		}

		.form-section-title i {
			font-size: 1.2rem;
		}

		.form-section-desc {
			font-size: 0.875rem;
			color: var(--tblr-secondary);
			margin-bottom: 16px;
		}

		/* Choice grid для radio/checkbox */
		.choice-grid {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
			gap: 12px;
		}

		.choice-item {
			position: relative;
		}

		.choice-item input {
			position: absolute;
			opacity: 0;
			width: 0;
			height: 0;
		}

		.choice-label {
			display: flex;
			align-items: center;
			gap: 12px;
			min-height: 54px;
			height: 100%;
			padding: 14px 16px;
			background: rgba(var(--tblr-bg-surface-rgb), 0.3);
			border: 2px solid var(--tblr-border-color);
			border-radius: 8px;
			transition: all 0.2s ease;
			cursor: pointer;
		}

		.choice-item:hover .choice-label {
			border-color: var(--tblr-primary);
			background: rgba(var(--tblr-primary-rgb), 0.1);
			transform: translateY(-2px);
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
		}

		.choice-item input:checked + .choice-label {
			border-color: var(--tblr-primary);
			background: rgba(var(--tblr-primary-rgb), 0.15);
			box-shadow: 0 0 0 3px rgba(var(--tblr-primary-rgb), 0.1);
		}

		.choice-emoji {
			font-size: 1.5rem;
			line-height: 1;
			flex-shrink: 0;
			width: 32px;
			text-align: center;
		}

		.choice-text {
			font-size: 0.95rem;
			font-weight: 500;
			line-height: 1.3;
			color: inherit;
			flex-grow: 1;
		}

		.choice-item input:checked + .choice-label .choice-text {
			font-weight: 600;
		}

		/* Scope editor */
		.scope-preset {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
			gap: 12px;
			margin-bottom: 20px;
		}

		.preset-btn {
			padding: 12px 16px;
			border: 2px solid var(--tblr-border-color);
			border-radius: 8px;
			background: rgba(var(--tblr-bg-surface-rgb), 0.3);
			cursor: pointer;
			transition: all 0.2s;
			font-weight: 500;
			text-align: left;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.preset-btn:hover {
			background: rgba(var(--tblr-primary-rgb), 0.1);
			border-color: var(--tblr-primary);
			transform: translateY(-2px);
		}

		.preset-btn.active {
			background: var(--tblr-primary);
			color: white;
			border-color: var(--tblr-primary);
			box-shadow: 0 4px 12px rgba(var(--tblr-primary-rgb), 0.3);
		}

		.scope-json {
			font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
			font-size: 13px;
			min-height: 200px;
			color: inherit;
			background: rgba(var(--tblr-bg-surface-rgb), 0.3);
			border: 2px solid var(--tblr-border-color);
			border-radius: var(--tblr-border-radius);
			padding: 12px;
			width: 100%;
		}

		/* Быстрые действия */
		.quick-actions {
			display: flex;
			gap: 8px;
			flex-wrap: wrap;
			margin-top: 1.5rem;
		}
    </style>
{% endblock %}

{% block form_content %}
    {{ super() }}

    <!-- Секция 1: Готовые настройки (Presets) -->
    <fieldset class="form-fieldset form-section">
        <div class="form-section-title">
            <i class="fa fa-magic"></i>
            Готовые шаблоны сценариев
        </div>
        <div class="form-section-desc">
            Выберите готовый шаблон для быстрой настройки
        </div>

        <div class="scope-preset">
            {% if form.presets %}
                {% for preset_key, preset_data in form.presets.items() %}
                    <button type="button" class="preset-btn choice-text" data-preset="{{ preset_key }}"
                            onclick="loadPreset('{{ preset_key }}')">
                        <span style="font-size: 1.2em;">{{ preset_data.icon }}</span> {{ preset_data.name }}
                    </button>
                {% endfor %}
            {% endif %}
        </div>
    </fieldset>

    <!-- Секция 2: Типы AI анализа -->
    <fieldset class="form-fieldset form-section">
        <div class="form-section-title">
            <i class="fa fa-brain"></i>
            Типы AI анализа
        </div>
        <div class="form-section-desc">
            Выберите один или несколько типов анализа для контента
        </div>

        <div class="choice-grid">
            {% if form.analysis_types_enum %}
                {% for analysis_type in form.analysis_types_enum %}
                    <div class="choice-item">
                        <input
                            type="checkbox"
                            value="{{ analysis_type.name.lower() }}"
                            id="analysis_{{ analysis_type.name.lower() }}"
                            class="analysis-type-input">
                        <label for="analysis_{{ analysis_type.name.lower() }}" class="choice-label">
                            <span class="choice-emoji">{{ analysis_type.emoji }}</span>
                            <span class="choice-text">{{ analysis_type.display_name }}</span>
                        </label>
                    </div>
                {% endfor %}
            {% endif %}
        </div>

        <div class="quick-actions">
            <button type="button" class="btn btn-sm btn-primary" onclick="selectAllAnalysisTypes()">
                <i class="fa fa-check-square"></i> Выбрать все
            </button>
            <button type="button" class="btn btn-sm btn-secondary" onclick="clearAllAnalysisTypes()">
                <i class="fa fa-square-o"></i> Очистить
            </button>
        </div>

        <label for="scope-json" style="margin-top: 20px;">Настройки переменных анализа (JSON)</label>
        <textarea class="scope-json" id="scope-json" name="scope" rows="10"></textarea>
        <div class="help-text">
            Конфиги автоматически добавляются при выборе типов анализа. Можно добавлять кастомные переменные.
        </div>

        <div class="quick-actions">
            <button type="button" class="btn btn-sm btn-secondary" onclick="formatScopeJSON()">
                <i class="fa fa-indent"></i> Форматировать
            </button>
            <button type="button" class="btn btn-sm btn-info" onclick="addVariable()">
                <i class="fa fa-plus"></i> Добавить переменную
            </button>
        </div>
    </fieldset>

    <!-- Секция 3: Типы контента -->
    <fieldset class="form-fieldset form-section">
        <div class="form-section-title">
            <i class="fa fa-list"></i>
            Типы контента для мониторинга
        </div>
        <div class="form-section-desc">
            Выберите какие типы контента будут анализироваться
        </div>

        <div class="choice-grid">
            {% if form.content_types_enum %}
                {% for content_type in form.content_types_enum %}
                    <div class="choice-item">
                        <input
                            type="checkbox"
                            value="{{ content_type.name.lower() }}"
                            id="content_{{ content_type.name.lower() }}"
                            class="content-type-input">
                        <label for="content_{{ content_type.name.lower() }}" class="choice-label">
                            <span class="choice-emoji">{{ content_type.emoji }}</span>
                            <span class="choice-text">{{ content_type.display_name }}</span>
                        </label>
                    </div>
                {% endfor %}
            {% endif %}
        </div>

        <div class="quick-actions">
            <button type="button" class="btn btn-sm btn-primary" onclick="selectAllContentTypes()">
                <i class="fa fa-check-square"></i> Выбрать все
            </button>
            <button type="button" class="btn btn-sm btn-secondary" onclick="clearAllContentTypes()">
                <i class="fa fa-square-o"></i> Очистить
            </button>
            <button type="button" class="btn btn-sm btn-info" onclick="selectCommonContentTypes()">
                <i class="fa fa-star"></i> Популярные
            </button>
        </div>
    </fieldset>

    <!-- Секция 4: Триггер -->
    <fieldset class="form-fieldset form-section">
        <div class="form-section-title">
            <i class="fa fa-bolt"></i>
            Условие срабатывания (Trigger)
        </div>
        <div class="form-section-desc">
            Выберите когда сценарий должен запускаться
        </div>

        <div class="choice-grid">
            {% if form.trigger_types_enum %}
                {% for trigger in form.trigger_types_enum %}
                    <div class="choice-item">
                        <input
                            type="radio"
                            name="trigger_type_radio"
                            value="{{ trigger.name }}"
                            data-db-value="{{ trigger.db_value }}"
                            id="trigger_{{ trigger.name }}"
                            class="trigger-type-input">
                        <label for="trigger_{{ trigger.name }}" class="choice-label">
                            <span class="choice-emoji">{{ trigger.emoji }}</span>
                            <span class="choice-text">{{ trigger.display_name }}</span>
                        </label>
                    </div>
                {% endfor %}
            {% endif %}
        </div>

        <label for="trigger-config-json" style="margin-top: 20px;">Настройки триггера (JSON)</label>
        <textarea class="scope-json" id="trigger-config-json" name="trigger_config" rows="8"></textarea>
        <div class="help-text">
            Конфигурация автоматически заполняется при выборе триггера. Можно редактировать вручную.
        </div>

        <div class="quick-actions">
            <button type="button" class="btn btn-sm btn-secondary" onclick="formatTriggerConfig()">
                <i class="fa fa-indent"></i> Форматировать
            </button>
            <button type="button" class="btn btn-sm btn-info" onclick="resetTriggerConfig()">
                <i class="fa fa-refresh"></i> Сбросить к дефолту
            </button>
            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="clearTriggerSelection()">
                <i class="fa fa-times"></i> Очистить выбор
            </button>
        </div>
    </fieldset>

    <!-- Секция 5: Действие -->
    <fieldset class="form-fieldset form-section">
        <div class="form-section-title">
            <i class="fa fa-play-circle"></i>
            Действие после анализа
        </div>
        <div class="form-section-desc">
            Что делать когда триггер сработал
        </div>

        <div class="choice-grid">
            {% if form.action_types_enum %}
                {% for action in form.action_types_enum %}
                    <div class="choice-item">
                        <input
                            type="radio"
                            name="action_type_radio"
                            value="{{ action.name }}"
                            id="action_{{ action.name }}"
                            class="action-type-input">
                        <label for="action_{{ action.name }}" class="choice-label">
                            <span class="choice-emoji">{{ action.emoji }}</span>
                            <span class="choice-text">{{ action.display_name }}</span>
                        </label>
                    </div>
                {% endfor %}
            {% endif %}
        </div>

        <div class="quick-actions">
            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="clearActionSelection()">
                <i class="fa fa-times"></i> Очистить выбор
            </button>
        </div>
    </fieldset>

{% endblock %}

{% block scripts %}
    {{ super() }}
    <script>
        // Presets data from Python config
        const presets = {{ form.presets|tojson if form.presets else '{}' }};

        // Analysis type defaults for auto-population of scope
        window.analysisDefaults = {{ form.analysis_defaults|tojson if form.analysis_defaults else '{}' }};
        
        // All possible analysis types for cleanup
        window.allAnalysisTypes = {{ form.all_analysis_types|tojson if form.all_analysis_types else '[]' }};
        
        // Trigger defaults for auto-population
        window.triggerDefaults = {{ form.trigger_defaults|tojson if form.trigger_defaults else '{}' }};
        
        // Flag to prevent auto-adding configs on initial load
        window.isInitialLoad = true;

        // Load preset
        function loadPreset(presetName) {
            const preset = presets[presetName]
            if (!preset) return

            // Load scope (includes analysis_types)
            document.getElementById("scope-json").value = JSON.stringify(preset.scope, null, 2)

            // Load content_types checkboxes
            clearAllContentTypes()
            if (preset.content_types) {
                preset.content_types.forEach(type => {
                    const checkbox = document.getElementById(`content_${type}`)
                    if (checkbox) checkbox.checked = true
                })
            }

            // Load analysis_types checkboxes (из отдельного поля пресета)
            clearAllAnalysisTypes()
            if (preset.analysis_types) {
                preset.analysis_types.forEach(type => {
                    const checkbox = document.getElementById(`analysis_${type}`)
                    if (checkbox) checkbox.checked = true
                })
            }

            // Load trigger_type (если есть в пресете)
            clearTriggerSelection()  // Сначала очищаем
            if (preset.trigger_type) {
                // trigger_type в пресете - это NAME (SENTIMENT_THRESHOLD)
                const radio = document.getElementById(`trigger_${preset.trigger_type}`)
                if (radio) {
                    radio.checked = true
                    lastSelectedTrigger = radio  // Для отслеживания deselection
                    console.log(`[Preset] Loaded trigger_type: ${preset.trigger_type}`)
                }
            }

            // Load trigger_config (если есть в пресете)
            if (preset.trigger_config) {
                const textarea = document.getElementById("trigger-config-json")
                textarea.value = JSON.stringify(preset.trigger_config, null, 2)
                console.log(`[Preset] Loaded trigger_config`)
            }

            // Load action_type (если есть в пресете)
            clearActionSelection()  // Сначала очищаем
            if (preset.action_type) {
                // action_type в пресете - это NAME (NOTIFICATION)
                const radio = document.getElementById(`action_${preset.action_type}`)
                if (radio) {
                    radio.checked = true
                    lastSelectedAction = radio  // Для отслеживания deselection
                    console.log(`[Preset] Loaded action_type: ${preset.action_type}`)
                }
            }

            // Update UI
            document.querySelectorAll(".preset-btn").forEach(btn => btn.classList.remove("active"))
            const presetBtn = document.querySelector(`.preset-btn[data-preset="${presetName}"]`)
            if (presetBtn) presetBtn.classList.add("active")

            // Sync to form
            syncContentTypesToForm()
            syncScopeToForm()
            syncTriggerToForm()
            syncActionToForm()
        }

        // Format JSON
        function formatScopeJSON() {
            const textarea = document.getElementById("scope-json")
            try {
                const obj = JSON.parse(textarea.value)
                textarea.value = JSON.stringify(obj, null, 2)
            } catch (e) {
                alert("Ошибка форматирования JSON: " + e.message)
            }
        }

        // Add variable
        function addVariable() {
            const textarea = document.getElementById("scope-json")
            const varName = prompt("Название переменной:")
            if (!varName) return

            const varValue = prompt("Значение переменной (или JSON):")
            if (!varValue) return

            try {
                const current = textarea.value ? JSON.parse(textarea.value) : {}
                try {
                    current[varName] = JSON.parse(varValue)
                } catch {
                    current[varName] = varValue
                }
                textarea.value = JSON.stringify(current, null, 2)
                syncScopeToForm()
            } catch (e) {
                alert("Ошибка: " + e.message)
            }
        }

        // Trigger functions
        function syncTriggerToForm() {
            const selected = document.querySelector(".trigger-type-input:checked");
            const triggerName = selected ? selected.value : null;  // NAME (KEYWORD_MATCH)
            const triggerDbValue = selected ? selected.dataset.dbValue : null;  // db_value (keyword_match)
            
            // Auto-fill trigger_config if new trigger selected (use db_value for defaults lookup)
            if (triggerDbValue && window.triggerDefaults && window.triggerDefaults[triggerDbValue]) {
                const configTextarea = document.getElementById("trigger-config-json");
                
                // Auto-fill only if empty or changed from another trigger
                const currentConfig = configTextarea.value.trim();
                if (!currentConfig || currentConfig === "{}") {
                    const defaultConfig = window.triggerDefaults[triggerDbValue];
                    configTextarea.value = JSON.stringify(defaultConfig, null, 2);
                    console.log(`[BotScenario] Auto-filled trigger_config for: ${triggerDbValue} (NAME: ${triggerName})`);
                }
            }
            
            // Create or update hidden field for trigger_type (use NAME for store_as_name=True)
            let triggerField = document.querySelector("input[name='trigger_type']");
            if (!triggerField) {
                const form = document.querySelector("form");
                if (!form) {
                    console.error("ERROR: Form not found when creating trigger_type field!");
                    return;
                }
                triggerField = document.createElement("input");
                triggerField.type = "hidden";
                triggerField.name = "trigger_type";
                form.appendChild(triggerField);
            }
            triggerField.value = triggerName || "";  // Save NAME
            console.log(`[BotScenario] trigger_type set to: ${triggerName}`);
        }
        
        function syncActionToForm() {
            const selected = document.querySelector(".action-type-input:checked");
            const actionName = selected ? selected.value : null;  // NAME (COMMENT)
            
            // Create or update hidden field for action_type (use NAME for store_as_name=True)
            let actionField = document.querySelector("input[name='action_type']");
            if (!actionField) {
                const form = document.querySelector("form");
                if (!form) {
                    console.error("ERROR: Form not found when creating action_type field!");
                    return;
                }
                actionField = document.createElement("input");
                actionField.type = "hidden";
                actionField.name = "action_type";
                form.appendChild(actionField);
            }
            actionField.value = actionName || "";  // Save NAME
            console.log(`[BotScenario] action_type set to: ${actionName}`);
        }
        
        function formatTriggerConfig() {
            const textarea = document.getElementById("trigger-config-json");
            try {
                const obj = JSON.parse(textarea.value);
                textarea.value = JSON.stringify(obj, null, 2);
            } catch (e) {
                alert("Ошибка форматирования JSON: " + e.message);
            }
        }
        
        function resetTriggerConfig() {
            const selected = document.querySelector(".trigger-type-input:checked");
            if (selected) {
                const triggerDbValue = selected.dataset.dbValue;
                if (window.triggerDefaults && window.triggerDefaults[triggerDbValue]) {
                    const textarea = document.getElementById("trigger-config-json");
                    textarea.value = JSON.stringify(window.triggerDefaults[triggerDbValue], null, 2);
                    alert("Конфигурация сброшена к дефолтным значениям");
                } else {
                    alert("Нет дефолтной конфигурации для этого триггера");
                }
            } else {
                alert("Выберите триггер сначала");
            }
        }
        
        function clearTriggerSelection() {
            // Uncheck all trigger radio buttons
            document.querySelectorAll(".trigger-type-input").forEach(radio => {
                radio.checked = false;
            });
            
            // Clear trigger_config textarea
            const textarea = document.getElementById("trigger-config-json");
            textarea.value = "";
            
            // Sync to form (will set hidden field to empty)
            syncTriggerToForm();
            
            console.log("[BotScenario] Trigger selection cleared");
        }
        
        function clearActionSelection() {
            // Uncheck all action radio buttons
            document.querySelectorAll(".action-type-input").forEach(radio => {
                radio.checked = false;
            });
            
            // Sync to form (will set hidden field to empty)
            syncActionToForm();
            
            console.log("[BotScenario] Action selection cleared");
        }

        // Analysis types functions
        function selectAllAnalysisTypes() {
            document.querySelectorAll(".analysis-type-input").forEach(cb => cb.checked = true)
            syncScopeToForm()
        }

        function clearAllAnalysisTypes() {
            document.querySelectorAll(".analysis-type-input").forEach(cb => cb.checked = false)
            syncScopeToForm()
        }

        // Content types functions
        function selectAllContentTypes() {
            document.querySelectorAll(".content-type-input").forEach(cb => cb.checked = true)
            syncContentTypesToForm()
        }

        function clearAllContentTypes() {
            document.querySelectorAll(".content-type-input").forEach(cb => cb.checked = false)
            syncContentTypesToForm()
        }

        function selectCommonContentTypes() {
            clearAllContentTypes();
            ["posts", "comments"].forEach(type => {
                const checkbox = document.getElementById(`content_${type}`)
                if (checkbox) checkbox.checked = true
            })
            syncContentTypesToForm()
        }

        // Sync to form fields
        function syncContentTypesToForm() {
            const selected = Array.from(document.querySelectorAll(".content-type-input:checked"))
                .map(cb => cb.value)

            // Создаем скрытое поле если его нет
            let contentTypesField = document.querySelector("input[name=\"content_types\"]")
            if (!contentTypesField) {
                const form = document.querySelector("form")
                if (!form) {
                    console.error("ERROR: Form not found when creating content_types field!")
                    return
                }
                contentTypesField = document.createElement("input")
                contentTypesField.type = "hidden"
                contentTypesField.name = "content_types"
                form.appendChild(contentTypesField)
            }
            contentTypesField.value = JSON.stringify(selected)
        }

        function syncScopeToForm() {
            // Get selected analysis types
            const selectedAnalysisTypes = Array.from(document.querySelectorAll(".analysis-type-input:checked"))
                .map(cb => cb.value)

            // Parse current scope JSON
            const scopeTextarea = document.getElementById("scope-json")
            let scope = {}
            try {
                scope = scopeTextarea.value ? JSON.parse(scopeTextarea.value) : {}
            } catch (e) {
                console.warn("Invalid JSON in scope, creating new scope object")
            }

            // НЕ добавляем analysis_types в scope - они теперь в отдельном поле!
            // Удаляем analysis_types из scope если они там есть
            delete scope.analysis_types

            // AUTO-ADD default configs ТОЛЬКО если это НЕ первоначальная загрузка
            if (!window.isInitialLoad) {
                selectedAnalysisTypes.forEach(type => {
                    // Добавляем config только если его нет в scope (БЕЗ _config!)
                    if (!scope[type] && window.analysisDefaults && window.analysisDefaults[type]) {
                        scope[type] = window.analysisDefaults[type];
                    }
                });
            }

            // REMOVE configs for unselected analysis types
            // Проверяем ВСЕ ключи в scope и удаляем configs для analysis types которые не выбраны
            if (window.allAnalysisTypes && window.allAnalysisTypes.length > 0) {
                window.allAnalysisTypes.forEach(type => {
                    // Если этот тип НЕ выбран - удаляем ОБА варианта ключа
                    if (!selectedAnalysisTypes.includes(type)) {
                        // Новый формат (БЕЗ _config)
                        if (scope.hasOwnProperty(type)) {
                            delete scope[type];
                        }
                        // Старый формат (С _config) - для обратной совместимости
                        const oldKey = `${type}_config`;
                        if (scope.hasOwnProperty(oldKey)) {
                            delete scope[oldKey];
                        }
                    }
                });
            }

            // Update textarea (без analysis_types)
            scopeTextarea.value = JSON.stringify(scope, null, 2)

            // Textarea уже существует (#scope-json с name="scope"), он и отправится в форме
            // Ничего дополнительно создавать не нужно!

            // Create or update hidden field for analysis_types (отдельно!)
            let analysisTypesField = document.querySelector("input[name=\"analysis_types\"]")
            if (!analysisTypesField) {
                const form = document.querySelector("form")
                if (!form) {
                    console.error("ERROR: Form not found when creating analysis_types field!")
                    return
                }
                analysisTypesField = document.createElement("input")
                analysisTypesField.type = "hidden"
                analysisTypesField.name = "analysis_types"
                form.appendChild(analysisTypesField)
            }
            analysisTypesField.value = JSON.stringify(selectedAnalysisTypes)
        }

        // Action type handled by sqladmin, no custom sync needed

        // Init on page load
        document.addEventListener("DOMContentLoaded", function() {
            // Add checkbox listeners for content types
            document.querySelectorAll(".content-type-input").forEach(cb => {
                cb.addEventListener("change", syncContentTypesToForm)
            })

            // Add checkbox listeners for analysis types (saves to scope)
            document.querySelectorAll(".analysis-type-input").forEach(cb => {
                cb.addEventListener("change", syncScopeToForm)
            })
            
            // Add radio listeners for trigger type
            // Allow deselection by clicking on selected radio
            let lastSelectedTrigger = null;
            document.querySelectorAll(".trigger-type-input").forEach(radio => {
                radio.addEventListener("change", syncTriggerToForm);
                
                // Allow deselection on second click
                radio.addEventListener("click", function() {
                    if (lastSelectedTrigger === this) {
                        // Clicked on already selected radio - deselect it
                        this.checked = false;
                        lastSelectedTrigger = null;
                        
                        // Clear trigger_config
                        const textarea = document.getElementById("trigger-config-json");
                        textarea.value = "";
                        
                        syncTriggerToForm();
                        console.log("[BotScenario] Trigger deselected by double-click");
                    } else {
                        lastSelectedTrigger = this;
                    }
                });
            });
            
            // Add radio listeners for action type
            // Allow deselection by clicking on selected radio
            let lastSelectedAction = null;
            document.querySelectorAll(".action-type-input").forEach(radio => {
                radio.addEventListener("change", syncActionToForm);
                
                // Allow deselection on second click
                radio.addEventListener("click", function() {
                    if (lastSelectedAction === this) {
                        // Clicked on already selected radio - deselect it
                        this.checked = false;
                        lastSelectedAction = null;
                        
                        syncActionToForm();
                        console.log("[BotScenario] Action deselected by double-click");
                    } else {
                        lastSelectedAction = this;
                    }
                });
            });

            // Sync scope on manual change
            const scopeJson = document.getElementById("scope-json")
            if (scopeJson) {
                scopeJson.addEventListener("change", function() {
                    // Просто синхронизируем scope, analysis_types теперь отдельно
                    syncScopeToForm()
                })
            }

            // Load initial values from model (edit mode)
            const initialContentTypes = {{ obj.content_types|tojson if obj and obj.content_types else '[]' }};
            if (initialContentTypes && initialContentTypes.length > 0) {
                initialContentTypes.forEach(type => {
                    const checkbox = document.getElementById(`content_${type}`)
                    if (checkbox) checkbox.checked = true
                })
            }

            // Analysis types - теперь отдельное поле!
            const initialAnalysisTypes = {{ obj.analysis_types|tojson if obj and obj.analysis_types else '[]' }};
            if (initialAnalysisTypes && initialAnalysisTypes.length > 0) {
                initialAnalysisTypes.forEach(type => {
                    const checkbox = document.getElementById(`analysis_${type}`)
                    if (checkbox) checkbox.checked = true
                })
            }
            
            // Trigger type (edit mode) - use NAME because store_as_name=True
            const initialTriggerType = {{ (obj.trigger_type.name if obj and obj.trigger_type else '')|tojson }};
            if (initialTriggerType) {
                const radio = document.getElementById(`trigger_${initialTriggerType}`);
                if (radio) {
                    radio.checked = true;
                    lastSelectedTrigger = radio;  // Set for deselection tracking
                    console.log(`[BotScenario] Loaded trigger_type NAME: ${initialTriggerType}`);
                }
            }
            
            // Trigger config (edit mode)
            const initialTriggerConfig = {{ obj.trigger_config|tojson if obj and obj.trigger_config else '{}' }};
            const triggerConfigTextarea = document.getElementById("trigger-config-json");
            if (triggerConfigTextarea && initialTriggerConfig && Object.keys(initialTriggerConfig).length > 0) {
                triggerConfigTextarea.value = JSON.stringify(initialTriggerConfig, null, 2);
            }
            
            // Action type (edit mode) - use NAME because store_as_name=True
            const initialActionType = {{ (obj.action_type.name if obj and obj.action_type else '')|tojson }};
            if (initialActionType) {
                const radio = document.getElementById(`action_${initialActionType}`);
                if (radio) {
                    radio.checked = true;
                    lastSelectedAction = radio;  // Set for deselection tracking
                    console.log(`[BotScenario] Loaded action_type NAME: ${initialActionType}`);
                }
            }

            // Scope (БЕЗ analysis_types - они теперь в отдельном поле)
            // ВАЖНО: Очищаем scope от analysis type configs которые НЕ выбраны
            const initialScope = {{ obj.scope|tojson if obj and obj.scope else '{}' }};
            const cleanedScope = {};
            
            if (initialScope && Object.keys(initialScope).length > 0) {
                // Копируем переменные в cleaned scope
                for (const [key, value] of Object.entries(initialScope)) {
                    // Проверяем является ли это analysis type config
                    const isAnalysisConfig = window.allAnalysisTypes && window.allAnalysisTypes.includes(key);
                    const isOldFormatConfig = key.endsWith('_config') && window.allAnalysisTypes && 
                        window.allAnalysisTypes.includes(key.replace('_config', ''));
                    
                    if (isAnalysisConfig || isOldFormatConfig) {
                        // Это analysis config
                        // Проверяем выбран ли этот analysis type в checkboxes
                        const analysisType = isOldFormatConfig ? key.replace('_config', '') : key;
                        const isSelected = initialAnalysisTypes.includes(analysisType);
                        
                        if (isSelected) {
                            // Тип выбран - сохраняем config (может быть кастомизирован)
                            // Используем новый формат (без _config)
                            cleanedScope[analysisType] = value;
                        }
                    } else {
                        // Это кастомная переменная, всегда оставляем
                        cleanedScope[key] = value;
                    }
                }
                
                scopeJson.value = JSON.stringify(cleanedScope, null, 2);
            }

            // Action type handled by sqladmin

            // Submit handler
            const form = document.querySelector("form")
            if (form) {
                let isSubmitting = false
                
                form.addEventListener("submit", function(e) {
                    // Prevent double submit
                    if (isSubmitting) {
                        e.preventDefault()
                        return false
                    }
                    
                    // Sync data before submit
                    syncContentTypesToForm()
                    syncScopeToForm()
                    syncTriggerToForm()
                    syncActionToForm()
                    
                    // Check if all required fields exist
                    const contentTypesField = document.querySelector("input[name='content_types']")
                    const analysisTypesField = document.querySelector("input[name='analysis_types']")
                    const scopeField = document.getElementById("scope-json")
                    
                    if (!contentTypesField || !analysisTypesField || !scopeField) {
                        console.error("Required fields missing")
                        e.preventDefault()
                        return false
                    }
                    
                    isSubmitting = true
                })
            }

            // Initial sync to create hidden fields
            syncContentTypesToForm()
            syncScopeToForm()  // Синхронизируем checkboxes и scope при загрузке
            syncTriggerToForm()  // Синхронизируем trigger
            syncActionToForm()  // Синхронизируем action
            
            // После первоначальной загрузки - разрешаем автодобавление
            window.isInitialLoad = false;
        })
    </script>
{% endblock %}
